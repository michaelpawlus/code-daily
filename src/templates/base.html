<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}code-daily{% endblock %}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        /* CSS Custom Properties for Theme System */
        :root {
            /* Light mode colors */
            --bg-primary: #f8fafc;
            --bg-secondary: #f1f5f9;
            --bg-card: #ffffff;
            --bg-card-hover: #f8fafc;
            --bg-input: #f1f5f9;
            --border-card: #e2e8f0;
            --border-input: #cbd5e1;

            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #94a3b8;

            /* Semantic colors */
            --accent-streak: #14b8a6;
            --accent-streak-light: #2dd4bf;
            --accent-goal: #22c55e;
            --accent-goal-light: #4ade80;
            --accent-achievement: #a855f7;
            --accent-achievement-light: #c084fc;
            --accent-warning: #f97316;
            --accent-warning-light: #fb923c;

            /* Heatmap colors (teal scale for light mode) */
            --heatmap-0: #e2e8f0;
            --heatmap-1: #99f6e4;
            --heatmap-2: #5eead4;
            --heatmap-3: #2dd4bf;
            --heatmap-4: #14b8a6;

            /* Shadow */
            --shadow-card: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-card-hover: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        .dark {
            /* Dark mode colors */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #1e293b;
            --bg-card-hover: #334155;
            --bg-input: #334155;
            --border-card: #334155;
            --border-input: #475569;

            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #64748b;

            /* Semantic colors stay the same */
            --accent-streak: #14b8a6;
            --accent-streak-light: #2dd4bf;
            --accent-goal: #22c55e;
            --accent-goal-light: #4ade80;
            --accent-achievement: #a855f7;
            --accent-achievement-light: #c084fc;
            --accent-warning: #f97316;
            --accent-warning-light: #fb923c;

            /* Heatmap colors (teal scale for dark mode) */
            --heatmap-0: #1e293b;
            --heatmap-1: #115e59;
            --heatmap-2: #0d9488;
            --heatmap-3: #14b8a6;
            --heatmap-4: #2dd4bf;

            /* Shadow */
            --shadow-card: 0 1px 3px 0 rgb(0 0 0 / 0.3), 0 1px 2px -1px rgb(0 0 0 / 0.3);
            --shadow-card-hover: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.3);
        }

        /* Base styles using CSS variables */
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-card);
            box-shadow: var(--shadow-card);
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-card-hover);
        }

        /* Streak ring animations */
        @keyframes ring-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes ring-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .ring-animate {
            animation: ring-rotate 8s linear infinite;
        }

        .ring-pulse {
            animation: ring-pulse 2s ease-in-out infinite;
        }

        /* Progress bar animation */
        @keyframes progress-fill {
            from { width: 0%; }
        }

        .progress-animate {
            animation: progress-fill 0.8s ease-out;
        }

        /* Heatmap styles */
        .heatmap-grid {
            display: flex;
            gap: 4px;
        }

        .heatmap-labels {
            display: grid;
            grid-template-rows: repeat(7, 12px);
            gap: 2px;
            font-size: 10px;
            color: var(--text-muted);
            padding-right: 4px;
        }

        .heatmap-cells {
            display: grid;
            grid-template-rows: repeat(7, 12px);
            grid-auto-flow: column;
            gap: 2px;
        }

        .heatmap-cell {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            transition: background-color 0.2s ease;
        }

        .level-0 { background-color: var(--heatmap-0); }
        .level-1 { background-color: var(--heatmap-1); }
        .level-2 { background-color: var(--heatmap-2); }
        .level-3 { background-color: var(--heatmap-3); }
        .level-4 { background-color: var(--heatmap-4); }

        /* Achievement styles */
        .achievement-unlocked {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(168, 85, 247, 0.05) 100%);
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .achievement-locked {
            background-color: var(--bg-secondary);
            opacity: 0.5;
        }

        /* Theme toggle button */
        .theme-toggle {
            background-color: var(--bg-card);
            border: 1px solid var(--border-card);
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: var(--bg-card-hover);
            color: var(--text-primary);
        }

        /* Input styles */
        .input-field {
            background-color: var(--bg-input);
            border: 1px solid var(--border-input);
            color: var(--text-primary);
            transition: border-color 0.2s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-streak);
        }

        /* Stat card accents */
        .stat-card {
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-streak), var(--accent-streak-light));
        }
    </style>
</head>
<body class="min-h-screen">
    {% block content %}{% endblock %}

    <script>
        // Theme management
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function getStoredTheme() {
            return localStorage.getItem('theme');
        }

        function setTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            localStorage.setItem('theme', theme);
            updateThemeIcon(theme);
        }

        function updateThemeIcon(theme) {
            const sunIcon = document.getElementById('sun-icon');
            const moonIcon = document.getElementById('moon-icon');
            if (sunIcon && moonIcon) {
                if (theme === 'dark') {
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                } else {
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                }
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            setTheme(currentTheme === 'dark' ? 'light' : 'dark');
        }

        // Initialize theme on page load
        (function() {
            const storedTheme = getStoredTheme();
            const theme = storedTheme || getSystemTheme();
            setTheme(theme);
        })();

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!getStoredTheme()) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });

        // Refresh data function
        async function refreshData() {
            const refreshBtn = document.getElementById('refresh-btn');
            const refreshIcon = document.getElementById('refresh-icon');
            const refreshSpinner = document.getElementById('refresh-spinner');

            if (refreshBtn) {
                refreshBtn.disabled = true;
                if (refreshIcon) refreshIcon.classList.add('hidden');
                if (refreshSpinner) refreshSpinner.classList.remove('hidden');
            }

            try {
                // Force a fresh fetch by adding a cache-busting parameter
                const response = await fetch(window.location.href, {
                    headers: { 'Cache-Control': 'no-cache' }
                });
                if (response.ok) {
                    window.location.reload();
                }
            } catch (error) {
                console.error('Refresh failed:', error);
                // Reset button state on error
                if (refreshBtn) {
                    refreshBtn.disabled = false;
                    if (refreshIcon) refreshIcon.classList.remove('hidden');
                    if (refreshSpinner) refreshSpinner.classList.add('hidden');
                }
            }
        }

        // Auto-retry logic: if commits today is 0 and it's past noon, retry after 60 seconds
        (function autoRetryCheck() {
            const todayText = document.querySelector('[data-goal-count]');
            if (todayText) {
                const match = todayText.textContent.match(/(\d+)\s*\/\s*\d+/);
                const commitsToday = match ? parseInt(match[1], 10) : null;
                const hour = new Date().getHours();

                // If 0 commits today and it's past noon, auto-retry once after 60 seconds
                if (commitsToday === 0 && hour >= 12) {
                    const hasRetried = sessionStorage.getItem('autoRetried');
                    if (!hasRetried) {
                        sessionStorage.setItem('autoRetried', 'true');
                        setTimeout(() => {
                            refreshData();
                        }, 60000); // 60 seconds
                    }
                } else {
                    // Reset retry flag if commits exist or it's before noon
                    sessionStorage.removeItem('autoRetried');
                }
            }
        })();

        // Goal form functions
        function toggleGoalForm() {
            const display = document.querySelector('[data-goal-display]');
            const form = document.querySelector('[data-goal-form]');
            const editBtn = document.querySelector('[data-goal-edit-btn]');

            if (form.classList.contains('hidden')) {
                display.classList.add('hidden');
                form.classList.remove('hidden');
                editBtn.classList.add('hidden');
            } else {
                display.classList.remove('hidden');
                form.classList.add('hidden');
                editBtn.classList.remove('hidden');
            }
        }

        async function saveGoal(event) {
            event.preventDefault();
            const input = document.getElementById('goal-input');
            const goal = parseInt(input.value, 10);

            if (goal < 1 || goal > 100) {
                alert('Goal must be between 1 and 100');
                return;
            }

            try {
                const response = await fetch('/api/goal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ goal: goal })
                });

                if (response.ok) {
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to save goal'));
                }
            } catch (error) {
                alert('Error saving goal: ' + error.message);
            }
        }

        // Quest functions
        function toggleQuestForm() {
            const form = document.querySelector('[data-quest-form]');
            const addBtn = document.querySelector('[data-quest-add-btn]');

            if (form.classList.contains('hidden')) {
                form.classList.remove('hidden');
                addBtn.classList.add('hidden');
                document.getElementById('quest-title').focus();
            } else {
                form.classList.add('hidden');
                addBtn.classList.remove('hidden');
                document.getElementById('quest-title').value = '';
                document.getElementById('quest-description').value = '';
            }
        }

        async function addQuest(event) {
            event.preventDefault();
            const title = document.getElementById('quest-title').value.trim();
            const description = document.getElementById('quest-description').value.trim();

            if (!title) {
                alert('Please enter a quest title');
                return;
            }

            try {
                const response = await fetch('/api/quests', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, description: description || null })
                });

                if (response.ok) {
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to create quest'));
                }
            } catch (error) {
                alert('Error creating quest: ' + error.message);
            }
        }

        async function acceptQuest(questId) {
            try {
                const response = await fetch(`/api/quests/${questId}/accept`, {
                    method: 'POST'
                });

                if (response.ok) {
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to accept quest'));
                }
            } catch (error) {
                alert('Error accepting quest: ' + error.message);
            }
        }

        async function completeQuest(questId) {
            try {
                const response = await fetch(`/api/quests/${questId}/complete`, {
                    method: 'POST'
                });

                if (response.ok) {
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to complete quest'));
                }
            } catch (error) {
                alert('Error completing quest: ' + error.message);
            }
        }

        let currentSkipQuestId = null;

        function showSkipOptions(questId) {
            currentSkipQuestId = questId;
            const modal = document.getElementById('skip-modal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideSkipModal() {
            currentSkipQuestId = null;
            const modal = document.getElementById('skip-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        async function skipQuest(action, saveAsIdea) {
            if (!currentSkipQuestId) return;

            try {
                const response = await fetch(`/api/quests/${currentSkipQuestId}/skip`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, save_as_idea: saveAsIdea })
                });

                if (response.ok) {
                    hideSkipModal();
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to skip quest'));
                }
            } catch (error) {
                alert('Error skipping quest: ' + error.message);
            }
        }

        // GitHub Issues sync function
        async function syncGitHubIssues() {
            const btn = document.getElementById('sync-github-btn');
            const textEl = document.getElementById('sync-github-text');
            const originalText = textEl.textContent;

            // Disable button and show loading state
            btn.disabled = true;
            textEl.textContent = 'Syncing...';

            try {
                const response = await fetch('/api/quests/sync-github-issues', {
                    method: 'POST'
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.added > 0) {
                        textEl.textContent = `Added ${data.added}!`;
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        textEl.textContent = 'No new issues';
                        setTimeout(() => {
                            textEl.textContent = originalText;
                            btn.disabled = false;
                        }, 2000);
                    }
                } else {
                    const data = await response.json();
                    alert('Error syncing issues: ' + (data.detail || 'Unknown error'));
                    textEl.textContent = originalText;
                    btn.disabled = false;
                }
            } catch (error) {
                alert('Error syncing issues: ' + error.message);
                textEl.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Ideas functions
        async function addIdea(event) {
            event.preventDefault();
            const input = document.getElementById('idea-input');
            const content = input.value.trim();

            if (!content) {
                return;
            }

            try {
                const response = await fetch('/api/ideas', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });

                if (response.ok) {
                    input.value = '';
                    // Show brief success feedback
                    input.placeholder = 'Idea saved!';
                    setTimeout(() => {
                        input.placeholder = 'Quick idea...';
                    }, 2000);
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to save idea'));
                }
            } catch (error) {
                alert('Error saving idea: ' + error.message);
            }
        }

        // Close skip modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('skip-modal');
            if (modal && event.target === modal) {
                hideSkipModal();
            }
        });

        // TODO scanner functions
        async function scanTodos() {
            const btn = document.getElementById('scan-todos-btn');
            const textEl = document.getElementById('scan-todos-text');
            const originalText = textEl.textContent;

            // Disable button and show loading state
            btn.disabled = true;
            textEl.textContent = 'Scanning...';

            try {
                const response = await fetch('/api/quests/scan-todos', {
                    method: 'POST'
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.added > 0) {
                        textEl.textContent = `Added ${data.added}!`;
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        textEl.textContent = 'No new TODOs';
                        setTimeout(() => {
                            textEl.textContent = originalText;
                            btn.disabled = false;
                        }, 2000);
                    }
                } else {
                    const data = await response.json();
                    alert('Error scanning TODOs: ' + (data.detail || 'Unknown error'));
                    textEl.textContent = originalText;
                    btn.disabled = false;
                }
            } catch (error) {
                alert('Error scanning TODOs: ' + error.message);
                textEl.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Copy source reference to clipboard
        async function copySourceRef(sourceRef) {
            try {
                await navigator.clipboard.writeText(sourceRef);
                // Show brief feedback - we could add a toast here
                const btn = event.target.closest('button');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg> Copied!';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 1500);
            } catch (error) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = sourceRef;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            }
        }
    </script>
</body>
</html>
